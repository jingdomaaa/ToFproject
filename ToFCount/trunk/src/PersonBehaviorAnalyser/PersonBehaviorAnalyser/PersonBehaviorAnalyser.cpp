// DepthObjectDetect.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。
//

#include "pch.h"
#define _CRT_SECURE_NO_DEPRECATE
#include <iostream>
#include <opencv2/highgui.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv2/videoio.hpp>
#include <opencv2/video.hpp>
#include <opencv2/tracking.hpp> 
using namespace std;
using namespace cv;
#pragma comment(lib, "opencv_highgui400d.lib")
#pragma comment(lib, "opencv_core400d.lib")
#pragma comment(lib, "opencv_imgproc400d.lib")
#pragma comment(lib, "opencv_imgcodecs400d.lib")
#pragma comment(lib, "opencv_videoio400d.lib")
#pragma comment(lib, "opencv_objdetect400d.lib")
#pragma comment(lib, "opencv_video400d.lib")
#pragma comment(lib, "opencv_tracking400d.lib")
int keyboard; //input from keyboard
void processVideo(char* videoFilename, int train);
void processFrame();
void  getMinMax(Mat &frame, vector<Point> contour, int *min, int *max);
int frameHeight = 480;
int frameWidth = 640;
char data_root[] = "F:\\ToF\\ToFCount\\trunk\\src\\PersonBehaviorAnalyser\\DataCapture";
char depth_data_file[] = "20190411101958.avi";
char result_file_path[256];
char depth_file_path[256];
cv::Mat frame;
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Mat theBackground; //Will hold the current background image as seen from the model
Mat diff_thresh; 
Mat result;
Mat im_color;
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
RNG rng(123456);

void  getMinMax(Mat &frame,vector<Point> contour,int *min,int *max)
{


}

void processFrame()
{
	/*
	double min, max;
	cv::minMaxIdx(frame, &min, &max);
	cout << "min=" << min << ",max=" << max << endl;
	*/
	for (int i = 0; i < frameHeight; i++)
	{
		for (int j = 0; j < frameWidth; j++)
		{
			
		}
	}
	
}
int main()
{
	int key;
	Mat im_color;
	int frame_count = 0;
	int number_to_train_on = 20;
	//cv::namedWindow("Image", cv::WINDOW_AUTOSIZE);
	cv::namedWindow("Frame", cv::WINDOW_AUTOSIZE);
	sprintf(depth_file_path, "%s\\%s", data_root, depth_data_file);
	sprintf(result_file_path, "%s\\result_%s", data_root, depth_data_file);
	//create Background Subtractor objects
	pMOG2 = createBackgroundSubtractorMOG2(); //MOG2 approach
	processVideo(depth_file_path, number_to_train_on);
	getchar();
}


void processVideo(char* videoFilename, int train) {
	//create the capture object
	VideoCapture capture(videoFilename);
	VideoWriter writer(result_file_path, VideoWriter::fourcc('M', 'J', 'P', 'G'), 15, Size(640, 480), 1);
	if (!capture.isOpened()) {
		//error in opening the video input
		cerr << "Unable to open video file: " << videoFilename << endl;
		exit(EXIT_FAILURE);
	}
	//read input data. ESC or 'q' for quitting
	double learning_rate = 0.1;
	int frame_count = 0;
	capture >> frame;
	Rect2d roi;
	double roi_left, roi_top, roi_right, roi_bottom;
	roi = selectROI("roi", frame);
	//quit if ROI was not selected
	if (roi.width == 0 || roi.height == 0)
	{
		cv::destroyAllWindows();
		exit(0);
	}
	roi_left = roi.x;
	roi_top = roi.y;
	roi_right = roi.x + roi.width;
	roi_bottom = roi.y + roi.height;
	//Mat mask = Mat(480, 640, CV_8UC3);
	Mat mask = Mat::zeros(frameHeight, frameWidth, CV_8UC3);
	for (int x = (int)roi_left; x <= (int)roi_right; x++)
	{
		for (int y = (int)roi_top; y <= (int)roi_bottom; y++)
		{
			mask.at<cv::Vec3b>(y, x)[0] = 255;
			mask.at<cv::Vec3b>(y, x)[1] = 255;
			mask.at<cv::Vec3b>(y, x)[2] = 255;
		}
	}
	//imshow("Mask", mask);
	while ((char)keyboard != 'q' && (char)keyboard != 27) {
		//read the current frame
		if (!capture.read(frame)) {
			cerr << "Unable to read next frame." << endl;
			cerr << "Exiting..." << endl;
			break;
		}
		
		frame_count = int(capture.get(CAP_PROP_POS_FRAMES)); //get frame#
		//update the background model
		if (frame_count == train) {
			learning_rate = 0;
		} //stop learning after training
		frame.copyTo(frame, mask);
		processFrame();

		pMOG2->apply(frame, fgMaskMOG2, learning_rate);
		applyColorMap(frame, im_color, COLORMAP_RAINBOW);
		//get the frame number and write it on the current frame
		stringstream ss;
		rectangle(frame, cv::Point(10, 2), cv::Point(100, 20),
			cv::Scalar(0, 255, 0), -1);
		ss << capture.get(CAP_PROP_POS_FRAMES);
		string frameNumberString = ss.str();
		putText(frame, frameNumberString.c_str(), cv::Point(15, 15),
			FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));

		rectangle(im_color, cv::Point(10, 2), cv::Point(100, 20),
			cv::Scalar(0, 255, 0), -1);
		putText(im_color, frameNumberString.c_str(), cv::Point(15, 15),
			FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar(0, 0, 0));

		result = im_color.clone();
		vector<vector<Point> > contours;
		threshold(fgMaskMOG2, diff_thresh, 50, 255, THRESH_BINARY);
		findContours(diff_thresh, contours, RETR_EXTERNAL, CHAIN_APPROX_NONE);
		rectangle(result, roi, Scalar(0, 0, 255), 2);
		line(result, Point(roi.x,roi.y+roi.height/2), Point(roi.x+roi.width, roi.y + roi.height / 2), cv::Scalar(255, 0, 0), 1);
		line(result, Point(roi.x, roi.y + roi.height*2 / 10), Point(roi.x + roi.width, roi.y + roi.height*2 / 10), cv::Scalar(255, 0, 0), 1);
		line(result, Point(roi.x, roi.y + roi.height * 8 / 10), Point(roi.x + roi.width, roi.y + roi.height * 8 / 10), cv::Scalar(255, 0, 0), 1);
		//show the current frame and the fg masks
		
		vector<Rect> boundRect(contours.size());
		double area;
		float center_x, center_y;
		Scalar color = Scalar(rng.uniform(0, 180), rng.uniform(0, 180), rng.uniform(0, 180));
		for (int i = 0; i < contours.size(); i++)
		{
			boundRect[i] = boundingRect(contours[i]);
			center_x = boundRect[i].x + boundRect[i].width/2;
			center_y = boundRect[i].y + boundRect[i].height/2;
			if (center_x >= roi_left && center_x <= roi_right && center_y >= roi_top && center_y <= roi_bottom)
			{
				area = contourArea(contours[i]);
				Moments mom = moments(contours[i], false);
				Point m = Point(static_cast<float>(mom.m10 / mom.m00), static_cast<float>(mom.m01 / mom.m00));
				cout << area << endl;
				if (area >= 6000)
				{
					drawContours(result, contours, -1, Scalar(0, 255, 0), 2);
					circle(result, m, 5, color, 2, 8);
					rectangle(result, boundRect[i], Scalar(0, 255, 0), 2);//在result上绘制正外接矩形 
				}
			}
		}
		
		imshow("Frame", frame);
		imshow("FG Mask MOG 2", fgMaskMOG2);
		imshow("Result", result);
		writer.write(result);
		pMOG2->getBackgroundImage(theBackground); //Get an image of the model's background
		//imshow("theBackground", theBackground);

		//get the input from the keyboard
		
		if (frame_count >= train) {
			//cout << "\nHit any key to continue\n" << endl;
			//keyboard = waitKey(); //single step with keyboard press in run mode
			keyboard = waitKey(10);
		}
		else {
			keyboard = waitKey(10); //run automatically in train mode
		}
		
	}
	
	//delete capture object
	capture.release();
	writer.release();
	cv::destroyAllWindows();
	
}
